\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage[pdftex,usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[table]{xcolor}
\usepackage[small,bf]{caption}
\usepackage{float}
\usepackage{subfig}
\usepackage{listings}
\usepackage{bm}
\usepackage{times}

\setcounter{secnumdepth}{5}

\begin{document}

\begin{titlepage}
	\thispagestyle{empty}
	\begin{center}
		\includegraphics[scale=0.7]{./images/itba.jpg}
		\vfill
		\Huge{Autómatas, Teoria de Lenguajes y Compiladores}\\
		\vspace{1cm}
		\huge{Trabajo Práctico Especial 2} \\
		\vspace{0.3cm}
		\huge{Title}
	\end{center}
	\vspace{2cm}
	\large{
		\begin{tabular}{lcr}
			Castiglione, Gonzalo & & 49138 \\
			Susnisky, Darío & & 50592 \\
			Ordano, Esteban & & 50753 \\
			Sturla, Martín & & 50684 \\
			\\ 
		\end{tabular}
	}
	\vfill
	\flushright{\today}
\end{titlepage}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%% begin CONTENT %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\thispagestyle{empty}
\tableofcontents

\newpage

\setcounter{page}{1}

\newpage

\section{Resumen}
El trabajo práctico consistió en generar un analizador sintáctico de partidas de ajedrez en formato \textit{PGN} 
para luego mostrar un tablero y poder hacer un seguimiento del partido.
\newpage

\section{Consideraciones realizadas}

\subsection{Formato PGN}

Como indica el enunciado, las partidas de ajedrez DEBEN tener el formato \textit{STG}. Además no se aceptan espacios de más, comentarios 
o anotaciones de variantes recursivas. Las etiquetas DEBEN aparecer en el orden Event, Site, Date, Round, White, Black, Result.
 Entre las etiquetas y las jugadas en formato \textit{SAN} debe haber un solo fin de línea y nada más (Nota: Se aceptan los finales de línea 
tanto de Windows como de Linux).

\subsection{ Validez de jugadas}

Existe una cierta validación de jugadas por parte del analizador, dado que se debe encontrar la pieza que se está moviendo. Esto implica que 
no pueden existir movimientos imposibles en cuanto a la naturaleza del movimiento de las piezas. Por otra parte, validaciones más complejas como 
por ejemplo restricciones para enrocar no son validadas.

\subsection{ Interfaz grafica}

Se optó por usar una interfaz gráfica que requiere librería SDL. Por lo tanto para compilar se deben instalar dos paquetes de la librería SDL; la librería 
estándar y la librería \textit{image}. En particular, en Ubuntu son las librerías \textit{libsdl1.2-dev} y \textit{libsdl-image1.2-dev}. Debido a estas 
dependencias que se agregaron, se decidió incluir el archivo compilado en la entrega final.

\newpage

\section{Descripción del desarrollo}
  Al igual que con el trabajo especial previo, al comenzar tratamos de diferenciar los distintos módulos de trabajo. 

  Una parte importante del trabajo implicaban leer el archivo .PGN, y validarlo con un \textit{parser} adecuado.
Luego, era necesario utilizar un analizador sintáctico para obtener los datos en distintos \textit{tokens}, ubicarlos en distintas
estructuras que fueron definidas con el proposito de poder procesar las jugadas según las reglas del ajedrez.
Finalmente, un módulo se encargaba del \textit{frontend} que implica la presentacion gráfica de la aplicación.

\subsection{Gramatica usada}

Notas: Los símbolos terminales son las palabars en mayúscula, que son \textit{tokens} devueltos por \textit{lex}. Los no terminales 
son aquellas en minúscula.

program $\Rightarrow$ option program | game 

option $\Rightarrow$ INITIAL_TOKEN STRING END_TOKEN  

option $\Rightarrow$ INITIAL_DATE_TOKEN INTEGER '.' INTEGER '.' INTEGER END_TOKEN 

option $\Rightarrow$ INITIAL_ROUND_TOKEN INTEGER END_TOKEN 

game $\Rightarrow$ round SPACE move SPACE move SPACE game | round SPACE move SPACE FINALRESULT | FINALRESULT | $\lambda$

round $\Rightarrow$ ROUND               

move $\Rightarrow$  castle check | normal_move check pawn_move   check 

normal_move $\Rightarrow$ PIECE COL ROW | PIECE CAPTURE COL ROW | PIECE COL COL ROW         

normal_move $\Rightarrow$ PIECE COL CAPTURE COL ROW | PIECE ROW COL ROW | PIECE ROW CAPTURE COL ROW 

pawn_move $\Rightarrow$ COL ROW | COL ROW COL ROW | COL CAPTURE COL ROW  | COL ROW CAPTURE COL ROW      
       
pawn_move $\Rightarrow$ COL ROW CROWN PIECE | COL CAPTURE COL ROW CROWN PIECE     

pawn_move $\Rightarrow$ COL ROW CAPTURE COL ROW CROWN PIECE | COL ROW COL ROW CROWN PIECE         

castle $\Rightarrow$ SHORTCASTLE   | LONGCASTLE   

check $\Rightarrow$ CHECK  | CHECKMATE  | $\lambda$

\subsection{Atributos de símbolos no terminales }

La mayoría de los \textit{tokens} devueltos por \textit{lex} tienen un valor asociado reperesntando qué es lo que se leyó. Por ejemplo, 
el atributo COL tiene el valor de la columna, ROW el valor de la fila, PIECE el carácter representando la pieza, etc.
De los símbolos no terminales, los únicos con valor son normal_move, pawn_move, move, castle, check y round. Round posee el valor númerico de la ronda, 
check un valor representando si hubo jaque, jaquemate o nada, y castle un valor representando si el enroque fue corto o largo. Normal_move, pawn_move 
y move poseen una estructura de tipo movimiento que posee muchos atributos, entre ellos, la pieza, su destino, si hubo jaque o no, enroque, etc. En las 
reescrituras del símbolo game, se llenan en esats estructuras devueltas por los movimientos asignándoles el color y se guardan en un vector para luego 
ser usadas por el \textit{front-end}.

\subsection{Lógica interna de la aplicación }

Al comenzar a armar las estructuras a usarse en la lógica interna de la aplicación, contamos como basico contar con estructuras
para representar el tablero y estructuras para representar las fichas. Después de cierto debate, decidimos apropiado que nuestro
tablero sea simplemente un vector de las 32 fichas, agregando dentro de la estructura ficha variables representando la fila y la 
columna. Esto se decidió ya que los casilleros no tienen ninguna propiedad en particular más que contener fichas o su color 
(sencillamente calculable).

Las fichas, contienen (además de su fila y su columna actual) su identificador único, su tipo de ficha, su color y si se encuentra 
viva.

Acompañadas de estas estructuras contabamos con metodos sencillos de representar los colores y los tipos de ficha (\textit{enums}).

Por otra parte, contamos con ciertas estructuras que representan lo que se lee del archivo de origen, estas son las estructuras que 
representan cada movimiento y la que representa el encabezado de cada archivo. Estas estructuras se definieron de forma sencilla a 
partir de los \textit{tokens} dados por el analizador sintactico.


\subsection{Lógica de la aplicación}

La lógica de la aplicación estaba dada por las reglas del ajedrez y simplemente consistía en corroborar que los movimientos dados
por el archivo respetasen estas reglas y ejecutar este movimiento para que tanto nuestras estructuras internas esten actualizadas 
según estos movimientos.

A continuación se presentan algunas cuestiones interesantes que debían ser validadas en este punto de la aplicación:
\begin{itemize}
 \item Detectar la ficha que se estaba moviendo.
 \item Que el movimiento sea valido para el tipo de pieza.
 \item Capturas.
 \item Coronaciones.
 \item Enroques.
\end{itemize}


\newpage

\section{Dificultades encontradas}
\newpage

\section{Futuras Extensiones}
   
\end{document}

